#### （一），什么是异常?
* 罗列出学习到目前为止，都接触过了哪些异常，分别在什么情况下会出现 
  * NullPointerException 空指针异常
  * ArithmeticException 除数为零
  * ClassCastException 类型转换异常
  * OutOfIndexException 数组下标越界异常
  * ParseException 解析异常，日期字符串转换为日期对象的时候，有可能抛出的异常
  * OutOfMemoryError 内存不足


* 处理
  * ```throws``` 需要好好看看
```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
  
//假设有一个方法 public int method()， 会返回一个整数
//在这个方法中有try catch 和 finally.
//try 里返回 1
//catch 里 返回 2
//finally 里 返回3
//那么，这个方法到底返回多少？
public class TestException {
    public static int method(){
        try {
            return 1;
        }catch (Exception e){
            return 2;
        }
        finally {
            return 3;
        }
    }
 
    public static void main(String[] args) {
        System.out.println(method());
    }
}

Out:
3

```

#### （三），```Java```中异常的分类（需要好好看看）

* 1，运行时异常 RuntimeException，能否被捕捉？
  * 运行时异常 RuntimeException 能被捕捉

* 2，错误Error，能否被捕捉？
  * 错误 Error 能被捕捉

* 3，面试题常问题： 运行时异常与非运行时异常的区别 
  * 运行时异常是不可查异常,不需要对其进行显式的捕捉
  * 非运行时异常是可查异常,必须要对其进行显式的捕捉,抛出,不然编译器会报错不允许程序运行.

 

#### （四），```Throwable```接口

* Throwable是类，Exception和Error都继承了该类

* 练习-```Throwable```
 * 在方法声明上，可以抛出指定的异常，比如FileNotFoundException那么能否抛出Throwable这个类？
 * 这个方法的调用者又该如何处理？

```
import java.io.File;
import java.io.FileInputStream;
//import java.io.FileNotFoundException;
 
public class Test {
    public static void main(String[] args) {
          
        File f = new File("d:/LOL.exe");
  
        try {
            new FileInputStream(f);
            //使用Throwable进行异常捕捉
        } catch (Throwable t) {
            // TODO Auto-generated catch block
            t.printStackTrace();
        }
  
    }
    }
    
Out:
java.io.FileNotFoundException: d:\LOL.exe (系统找不到指定的文件。)
    at java.io.FileInputStream.open0(Native Method)
    at java.io.FileInputStream.open(FileInputStream.java:195)
    at java.io.FileInputStream.<init>(FileInputStream.java:138)
    at operation.Test.main(Test.java:13)
    
不会输出Throwable这个类

```


#### （五），自定义异常

* 创建自定义异常
```
在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常
1. 创建一个EnemyHeroIsDeadException实例
2. 通过throw 抛出该异常
3. 当前方法通过 throws 抛出该异常

在外部调用attack方法的时候，就需要进行捕捉，并且捕捉的时候，可以通过e.getMessage() 获取当时出错的具体原因 
```


```
public class Hero {
    public String name;
    protected float hp;
 
    public void attackHero(Hero h) throws EnemyHeroIsDeadException{
        if(h.hp == 0){
            throw new EnemyHeroIsDeadException(h.name + " 已经挂了,不需要施放技能" );
        }
    }
 
    public String toString(){
        return name;
    }
     
    class EnemyHeroIsDeadException extends Exception{
         
        public EnemyHeroIsDeadException(){
             
        }
        public EnemyHeroIsDeadException(String msg){
            super(msg);
        }
    }
      
    public static void main(String[] args) {
         
        Hero garen =  new Hero();
        garen.name = "盖伦";
        garen.hp = 616;
 
        Hero teemo =  new Hero();
        teemo.name = "提莫";
        teemo.hp = 0;
         
        try {
            garen.attackHero(teemo);
             
        } catch (EnemyHeroIsDeadException e) {
            // TODO Auto-generated catch block
            System.out.println("异常的具体原因:"+e.getMessage());
            e.printStackTrace();
        }
         
    }
}

Out:
异常的具体原因:提莫 已经挂了,不需要施放技能
Hero$EnemyHeroIsDeadException: 提莫 已经挂了,不需要施放技能
        at Hero.attackHero(Hero.java:7)
        at Hero.main(Hero.java:36)

```

* 练习-自定义异常
 * 对```MyStringBuffer```的插入和删除方法中的边界条件判断，用抛出异常来解决
 * 终于知道 ```MyStringBuffer```的作用了，这是使用了```IStringBuffer```接口来写的，太多了，这段时间先不写了
 
 
 
 























  
